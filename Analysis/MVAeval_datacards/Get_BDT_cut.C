#include "TH1F.h"
#include <cmath>
#include <fstream>
#include <stdio.h>
#include <iostream>
#include <algorithm>

using namespace std;

struct BDTcut {
  float a;
  float b;
};

double TH1_integral (TH1F *h, float xmin, float xmax){
    TAxis *axis = h->GetXaxis();
    int bmin = axis->FindBin(xmin);
    int bmax = axis->FindBin(xmax);
    double integral = h->Integral(bmin,bmax);
    integral -= h->GetBinContent(bmin)*(xmin-axis->GetBinLowEdge(bmin))/axis->GetBinWidth(bmin);
    integral -= h->GetBinContent(bmax)*(axis->GetBinUpEdge(bmax)-xmax)/ axis->GetBinWidth(bmax);

    return integral;
}
BDTcut Get_BDT_cut(TString categ) 
{
    //Check on input argument
    if(strcmp(categ, "A") != 0 && strcmp(categ, "B") != 0 && strcmp(categ, "C") != 0){
          cout << "Please choose between 'A', 'B' and 'C'" << endl;
    return{-999,-999};
    }
      
    //pull path of root files generated by TMVA
    TString file_name= "TMVA_file_"+categ+".root";
    float a,b;
    double N_s_1, N_b_1;
    double N_s_2, N_b_2;
    double S1, S2, S;
    std::vector<double> S1_list, S2_list, S_list, a_list, b_list;
    Double_t sig_norm = 0.0014; //average normalization factor for the three signal samples
    TFile *f = new TFile(file_name,"READ");
    TH1F *h_test_signal;
    TH1F *h_test_bkg;
    //high granularity BDT scores
    h_test_signal = (TH1F*)f->Get("dataset_"+categ+"/Method_BDT/BDT/MVA_BDT_S_high");
    h_test_bkg = (TH1F*)f->Get("dataset_"+categ+"/Method_BDT/BDT/MVA_BDT_B_high");
    //h_test_signal = (TH1F*)f->Get("dataset/Method_BDT/BDT/MVA_BDT_S");
    //h_test_bkg = (TH1F*)f->Get("dataset/Method_BDT/BDT/MVA_BDT_B");

    //Signal is normalized to "sig_norm" factor
    h_test_signal->Scale(sig_norm);

    double X_min = std::min(h_test_signal->GetXaxis()->GetXmin(), h_test_signal->GetXaxis()->GetXmin());
    double X_max = std::max(h_test_signal->GetXaxis()->GetXmax(), h_test_signal->GetXaxis()->GetXmax());
    //Loop on both cuts in [X_min;X_max]
    Int_t dim = 0;
    //Increase N to increase (a,b) scan granularity!
    Int_t N = 350; double step = (X_max - X_min)/N;
    for(int i=0; i<N; i++){
	a = X_min + i * step;
	for(int j=0; j<N; j++){
	    b = X_min + j * step;
            if(a<b) continue;
            //computing areas in range [a;X_max]
	    N_s_1 = TH1_integral(h_test_signal,a,X_max);
	    N_b_1 = TH1_integral(h_test_bkg,a,X_max);
            //skip iteration if integral in the tails is < 0.05% of total (sensitive to fluctuations!)
            if(N_s_1 < TH1_integral(h_test_signal,X_min,X_max)*0.0005) continue;
            if(N_b_1 < TH1_integral(h_test_bkg,X_min,X_max)*0.0005) continue;
            //computing areas in range [b;a]
	    N_s_2 = TH1_integral(h_test_signal,b,a);
            N_b_2 = TH1_integral(h_test_bkg,b,a);
 	    if ( (N_b_1)>0 && (N_b_2)>0 ) {
                S1 = N_s_1 / sqrt(N_s_1 + N_b_1);
		S2 = N_s_2 / sqrt(N_s_2 + N_b_2);
	        //Combined significance
	        S = sqrt(S1*S1 + S2*S2);
	        a_list.push_back(a);
	        b_list.push_back(b);
	        S_list.push_back(S);
   	        dim++;
	    }
	}
    }
    //Taking absolute maximum of the combined significance
    double S_max = *max_element(S_list.begin(), S_list.end());
    int S_maxIndex = std::max_element(S_list.begin(),S_list.end()) - S_list.begin();
    float a_max = a_list.at(S_maxIndex);
    float b_max = b_list.at(S_maxIndex);
    cout<<"Category "<<categ<<endl;
    cout<<"b cut: "<<b_max<<" a cut: "<<a_max<<endl;
    cout<<"S value: "<<S_max<<endl;

    //Computing cut efficiency on signal
    Double_t N_S_12 = TH1_integral(h_test_signal,b_max,X_max);
    Double_t N_S_tot = TH1_integral(h_test_signal,X_min,X_max);
    cout<<"Signal events kept by BDT "<<N_S_12<<" over "<<N_S_tot<<" ratio: "<<N_S_12/N_S_tot<<endl;
    //Computing cut efficiency on backgroup
    Double_t N_B_12 = TH1_integral(h_test_bkg,b_max,X_max);
    Double_t N_B_tot = TH1_integral(h_test_bkg,X_min,X_max);
    cout<<"Background events kept by BDT "<<N_B_12<<" over "<<N_B_tot<<" ratio: "<<N_B_12/N_B_tot<<endl;
    
    return {a_max,b_max};
}
