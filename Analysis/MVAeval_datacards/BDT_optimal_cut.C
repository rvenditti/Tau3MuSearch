#include "TH1F.h"
#include <cmath>
#include <fstream>

double TH1_integral (TH1F *h, float xmin, float xmax){
    TAxis *axis = h->GetXaxis();
    int bmin = axis->FindBin(xmin);
    int bmax = axis->FindBin(xmax);
    double integral = h->Integral(bmin,bmax);
    integral -= h->GetBinContent(bmin)*(xmin-axis->GetBinLowEdge(bmin))/axis->GetBinWidth(bmin);
    integral -= h->GetBinContent(bmax)*(axis->GetBinUpEdge(bmax)-xmax)/ axis->GetBinWidth(bmax);

    return integral;
}
void BDT_optimal_cut() 
{
    TString cat_name[] = {"A",
                          "B+C"};
    int n_cat = sizeof(cat_name) / sizeof(cat_name[0]);
    float a,b;
    double N_s_1, N_b_1;
    double N_s_2, N_b_2;
    double S1, S2, S;
    std::vector<double> S1_list, S2_list, S_list, a_list, b_list;
    Double_t sig_norm = 0.00072; //average normalization factor for the three signal samples
    TString Method = "BDT"; //"BDT"
    for(int k=0; k<n_cat; k++)
    {
            //pull path of root files generated by TMVA
            TString file_name = "TMVA_file_"+cat_name[k]+".root";
	    TFile *f = new TFile(file_name,"READ");

	    TH1F *h_test_signal;
	    TH1F *h_test_bkg;
	    TH1F *h_test_signal2;
	    TH1F *h_test_bkg2;
            //high granularity BDT scores
	    h_test_signal = (TH1F*)f->Get("dataset_"+cat_name[k]+"/Method_"+Method+"/"+Method+"/MVA_"+Method+"_S_high");
	    h_test_bkg = (TH1F*)f->Get("dataset_"+cat_name[k]+"/Method_"+Method+"/"+Method+"/MVA_"+Method+"_B_high");
            //Normal binning BDT scores
	    h_test_signal2 = (TH1F*)f->Get("dataset_"+cat_name[k]+"/Method_"+Method+"/"+Method+"/MVA_"+Method+"_S");
	    h_test_bkg2 = (TH1F*)f->Get("dataset_"+cat_name[k]+"/Method_"+Method+"/"+Method+"/MVA_"+Method+"_B");
            h_test_signal->SetDirectory(0);
            h_test_bkg->SetDirectory(0);
            h_test_signal2->SetDirectory(0);
            h_test_bkg2->SetDirectory(0);
            f->Close();

	    //Signal is normalized to "sig_norm" factor
	    h_test_signal->Scale(sig_norm);
	    //Make up on plots
	    h_test_signal->GetXaxis()->SetRangeUser(-0.5,0.5);
	    h_test_signal->SetLineColor(kRed);

            double X_min = std::min(h_test_signal->GetXaxis()->GetXmin(), h_test_signal->GetXaxis()->GetXmin());
            double X_max = std::max(h_test_signal->GetXaxis()->GetXmax(), h_test_signal->GetXaxis()->GetXmax());
            //Loop on both cuts in [X_min;X_max]
	    Int_t dim = 0;
            //Increase N to increase (a,b) scan granularity!
            Int_t N = 350; double step = (X_max - X_min)/N;
	    for(int i=0; i<N; i++){
		a = X_min + i * step;
		for(int j=0; j<N; j++){
		    b = X_min + j * step;
                    if(a<b) continue;
                    //computing areas in range [a;X_max]
		    N_s_1 = TH1_integral(h_test_signal,a,X_max);
		    N_b_1 = TH1_integral(h_test_bkg,a,X_max);
                    //skip iteration if integral in the tails is < 0.1% of total (sensitive to fluctuations!)
                    if(N_s_1 < TH1_integral(h_test_signal,X_min,X_max)*0.001) continue;
                    if(N_b_1 < TH1_integral(h_test_bkg,X_min,X_max)*0.001) continue;
                    //computing areas in range [b;a]
		    N_s_2 = TH1_integral(h_test_signal,b,a);
                    N_b_2 = TH1_integral(h_test_bkg,b,a);
                    //skip iteration if integral in cat 2 is < 0.1% of total (sensitive to fluctuations!)
                    if(N_s_2 < TH1_integral(h_test_signal,X_min,X_max)*0.001) continue;
                    if(N_b_2 < TH1_integral(h_test_bkg,X_min,X_max)*0.001) continue;
	 	    if ( (N_b_1)>0 && (N_b_2)>0 ) {
	                S1 = N_s_1 / sqrt(N_s_1 + N_b_1);
			S2 = N_s_2 / sqrt(N_s_2 + N_b_2);
			//S1 = sqrt( 2*( (N_s_1+N_b_1)*log(1+ (N_s_1/N_b_1)) - N_s_1 ) );
			//S2 = sqrt( 2*( (N_s_2+N_b_2)*log(1+ (N_s_2/N_b_2)) - N_s_2 ) );
		        //Combined significance
		        S = sqrt(S1*S1 + S2*S2);
		        a_list.push_back(a);
		        b_list.push_back(b);
		        S_list.push_back(S);
	   	        dim++;
		    }
		}
	    }
	    TCanvas *c3 = new TCanvas("c3","c3",150,10,990,660);
	    TGraph2D *g2d = new TGraph2D(dim, &a_list[0], &b_list[0], &S_list[0]);
	    g2d->SetTitle(cat_name[k]+";a;b");
	    g2d->Draw("colz");    
            //g2d->GetHistogram()->SetMinimum(0.25);
            c3->Update();

            //Taking absolute maximum of the combined significance
	    double S_max = *max_element(S_list.begin(), S_list.end());
	    int S_maxIndex = std::max_element(S_list.begin(),S_list.end()) - S_list.begin();
	    float a_max = a_list.at(S_maxIndex);
	    float b_max = b_list.at(S_maxIndex);
	    cout<<"Category "<<cat_name[k]<<endl;
	    cout<<"b cut: "<<b_max<<" a cut: "<<a_max<<endl;
	    cout<<"S value: "<<S_max<<endl;

            //Computing cut efficiency on signal
            Double_t N_S_12 = TH1_integral(h_test_signal,b_max,X_max);
            Double_t N_S_tot = TH1_integral(h_test_signal,X_min,X_max);
            cout<<"Signal events kept by classifier: "<<N_S_12<<" over "<<N_S_tot<<" ratio: "<<N_S_12/N_S_tot<<endl;
            //Computing cut efficiency on backgroup
            Double_t N_B_12 = TH1_integral(h_test_bkg,b_max,X_max);
            Double_t N_B_tot = TH1_integral(h_test_bkg,X_min,X_max);
            cout<<"Background events kept by classifier: "<<N_B_12<<" over "<<N_B_tot<<" ratio: "<<N_B_12/N_B_tot<<endl;
	    
            TLine l;
            l.DrawLine(a_max,X_min,a_max,X_max);
            l.DrawLine(X_min,b_max,X_max,b_max);

	    c3->Update();
	    c3->SaveAs(Method+"_2Dmap_"+cat_name[k]+".png");

	    TCanvas *c1 = new TCanvas("c1","c1",150,10,990,660);
	    h_test_bkg->Draw();
	    h_test_signal->Draw("same");
	    c1->Update();
            l.DrawLine(a_max,0,a_max,0.1);
            l.DrawLine(b_max,0,b_max,0.1);

	    TLegend*leg = new TLegend(0.1,0.7,0.48,0.9);
	    leg->AddEntry(h_test_signal,cat_name[k]+"_signal","f");
	    leg->AddEntry(h_test_bkg,cat_name[k]+"_bkg","f");
	    leg->Draw();
	    c1->Update();
            c1->SaveAs(Method+"_"+cat_name[k]+"normalizedSignal.png");

            //Drawing BDT score from scratch without signal normalization
	    TCanvas *c2 = new TCanvas("c2","c2",150,10,990,660);
	    h_test_signal2->GetXaxis()->SetRangeUser(X_min,X_max);
	    h_test_signal2->SetLineColor(kRed);
	    h_test_signal2->Scale(1/h_test_signal2->GetEntries());
	    h_test_bkg2->Scale(1/h_test_bkg2->GetEntries());
            double Y_max = std::max(h_test_signal2->GetMaximum(), h_test_bkg2->GetMaximum());
	    h_test_bkg2->Draw();
	    h_test_bkg2->GetYaxis()->SetRangeUser(0, Y_max);
	    h_test_signal2->Draw("same");
	    c2->Update();
            l.DrawLine(a_max,0,a_max,Y_max);
            l.DrawLine(b_max,0,b_max,Y_max);
            TLatex ta(a_max,0,"a");
            ta.Draw();
            TLatex tb(b_max,0,"b");
            tb.Draw();

	    TLegend*leg2 = new TLegend(0.1,0.7,0.48,0.9);
	    leg2->AddEntry(h_test_signal2,cat_name[k]+"_signal","f");
	    leg2->AddEntry(h_test_bkg2,cat_name[k]+"_bkg","f");
	    leg2->Draw();
	    c2->Update();
            c2->SaveAs(Method+"_"+cat_name[k]+".png");

	    S_list.clear();
	    S1_list.clear();
	    S2_list.clear();
	    a_list.clear();
	    b_list.clear();
     }
}
